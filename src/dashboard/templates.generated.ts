// AUTO-GENERATED by scripts/gen_templates.ts — do not edit manually.
// Re-generate with: deno run -A scripts/gen_templates.ts

export const base = "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>mcp-stress — {{TITLE}}</title>\n<script src=\"https://cdn.plot.ly/plotly-3.3.1.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/html-to-image@1.11.13/dist/html-to-image.js\"></script>\n<style>\n{{STYLES}}\n</style>\n</head>\n<body>\n<div class=\"header\">\n  <div class=\"header-left\">\n    <h1>mcp-stress results</h1>\n    <div class=\"meta\" id=\"meta\"></div>\n  </div>\n  <div class=\"header-actions\">\n    <button class=\"header-btn\" id=\"save-image\">Save as image</button>\n    <button class=\"header-btn\" id=\"copy-summary\" style=\"display:none\">Copy summary</button>\n    <button class=\"header-btn\" id=\"theme-toggle\">Light mode</button>\n  </div>\n</div>\n<div class=\"stats\" id=\"stats\"></div>\n\n<div class=\"section\" id=\"run-params\"></div>\n<div class=\"section engine-log\" id=\"engine-log\" style=\"display:none\"></div>\n\n<div class=\"charts\">\n  <div class=\"chart full\">\n    <div id=\"throughput\" class=\"plot\"></div>\n    <div class=\"chart-help\" id=\"help-throughput\"></div>\n  </div>\n  <div class=\"chart full\">\n    <div id=\"latency-time\" class=\"plot tall\"></div>\n    <div class=\"chart-help\" id=\"help-latency-time\"></div>\n  </div>\n  <div class=\"chart\">\n    <div id=\"latency-hist\" class=\"plot\"></div>\n    <div class=\"chart-help\" id=\"help-latency-hist\"></div>\n  </div>\n  <div class=\"chart\">\n    <div id=\"latency-box\" class=\"plot\"></div>\n    <div class=\"chart-help\" id=\"help-latency-box\"></div>\n  </div>\n  <div class=\"chart full\" id=\"concurrency-section\">\n    <div id=\"concurrency\" class=\"plot tall\"></div>\n    <div class=\"chart-help\" id=\"help-concurrency\"></div>\n  </div>\n</div>\n\n<div id=\"compare-section\" style=\"display:none\"></div>\n\n<script>\n{{DATA}}\n</script>\n<script>\n{{SCRIPTS}}\n</script>\n</body>\n</html>\n";

export const styles = ":root {\n  --bg: #0d1117;\n  --bg-card: #161b22;\n  --bg-insight: #1c2128;\n  --bg-anomaly: #2d1b1b;\n  --border: #21262d;\n  --grid: #21262d;\n  --zeroline: #30363d;\n  --text: #c9d1d9;\n  --text-heading: #f0f6fc;\n  --text-muted: #8b949e;\n  --text-faint: #6e7681;\n  --text-dimmed: #484f58;\n  --accent: #58a6ff;\n  --green: #3fb950;\n  --yellow: #d29922;\n  --red: #da3633;\n  --purple: #bc8cff;\n  --repro-bg: #161b22;\n  --repro-text: #3fb950;\n}\n[data-theme=\"light\"] {\n  --bg: #ffffff;\n  --bg-card: #f6f8fa;\n  --bg-insight: #f0f4f8;\n  --bg-anomaly: #fff0f0;\n  --border: #d0d7de;\n  --grid: #e8eaed;\n  --zeroline: #d0d7de;\n  --text: #1f2328;\n  --text-heading: #1f2328;\n  --text-muted: #59636e;\n  --text-faint: #8b949e;\n  --text-dimmed: #8b949e;\n  --accent: #0969da;\n  --green: #1a7f37;\n  --yellow: #9a6700;\n  --red: #d1242f;\n  --purple: #8250df;\n  --repro-bg: #f6f8fa;\n  --repro-text: #1a7f37;\n}\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\nbody {\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, monospace;\n  background: var(--bg);\n  color: var(--text);\n  transition: background 0.2s, color 0.2s;\n}\na {\n  color: var(--accent);\n}\n\n.header {\n  padding: 20px 32px;\n  border-bottom: 1px solid var(--border);\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n.header-left h1 {\n  font-size: 20px;\n  font-weight: 600;\n}\n.header-left .meta {\n  font-size: 13px;\n  color: var(--text-muted);\n  margin-top: 4px;\n}\n.header-actions {\n  display: flex;\n  gap: 8px;\n}\n.header-btn {\n  background: var(--bg-card);\n  border: 1px solid var(--border);\n  border-radius: 6px;\n  padding: 6px 12px;\n  cursor: pointer;\n  font-size: 13px;\n  color: var(--text-muted);\n  transition: all 0.2s;\n}\n.header-btn:hover {\n  border-color: var(--accent);\n  color: var(--text);\n}\n.header-btn:disabled {\n  opacity: 0.4;\n  cursor: default;\n}\n\n.stats {\n  display: flex;\n  gap: 32px;\n  padding: 16px 32px;\n  border-bottom: 1px solid var(--border);\n  flex-wrap: wrap;\n}\n.stat {\n  text-align: center;\n  min-width: 80px;\n}\n.stat .value {\n  font-size: 28px;\n  font-weight: 700;\n  color: var(--accent);\n}\n.stat .value.warn {\n  color: var(--yellow);\n}\n.stat .value.bad {\n  color: var(--red);\n}\n.stat .label {\n  font-size: 12px;\n  color: var(--text-muted);\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.section {\n  padding: 16px 32px;\n  border-bottom: 1px solid var(--border);\n}\n.section h2 {\n  font-size: 14px;\n  font-weight: 600;\n  margin-bottom: 8px;\n  color: var(--text-heading);\n}\n.section p, .section li {\n  font-size: 13px;\n  color: var(--text-muted);\n  line-height: 1.6;\n}\n.section ul {\n  margin-left: 20px;\n}\n\n.params {\n  display: grid;\n  grid-template-columns: auto 1fr;\n  gap: 2px 16px;\n  font-size: 13px;\n}\n.params dt {\n  color: var(--text-muted);\n}\n.params dd {\n  color: var(--text);\n  font-family: monospace;\n}\n\n.repro {\n  background: var(--repro-bg);\n  border: 1px solid var(--border);\n  border-radius: 6px;\n  padding: 12px;\n  margin-top: 8px;\n  font-family: monospace;\n  font-size: 12px;\n  color: var(--repro-text);\n  white-space: pre-wrap;\n  word-break: break-all;\n  cursor: pointer;\n  position: relative;\n}\n.repro:hover {\n  border-color: var(--green);\n}\n.repro .repro-hint {\n  position: absolute;\n  right: 8px;\n  top: -10px;\n  font-size: 10px;\n  color: var(--text-dimmed);\n  background: var(--bg);\n  padding: 1px 6px;\n  border-radius: 3px;\n  border: 1px solid var(--border);\n  transition: all 0.15s;\n}\n.repro .repro-hint.copied {\n  color: var(--green);\n  border-color: var(--green);\n}\n\n.charts {\n  padding: 16px;\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n  gap: 16px;\n}\n.chart {\n  background: var(--bg-card);\n  border: 1px solid var(--border);\n  border-radius: 8px;\n  padding: 8px;\n  display: grid;\n  grid-template-columns: 1fr;\n  gap: 0;\n  overflow: visible;\n}\n.chart.full {\n  grid-column: 1 / -1;\n  grid-template-columns: 1fr 280px;\n}\n.chart.full .chart-help {\n  border-left: 1px solid var(--border);\n  border-top: none;\n}\n.chart:not(.full) .chart-help {\n  border-top: 1px solid var(--border);\n  border-left: none;\n  max-height: none;\n}\n\n.chart-help {\n  font-size: 12px;\n  color: var(--text-muted);\n  padding: 12px 16px;\n  line-height: 1.7;\n  overflow: visible;\n}\n.chart-help .title {\n  color: var(--text-heading);\n  font-weight: 600;\n  display: block;\n  margin-bottom: 6px;\n  font-size: 13px;\n}\n.chart-help .legend {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 12px;\n  margin-bottom: 8px;\n}\n.chart-help .legend-item {\n  display: flex;\n  align-items: center;\n  gap: 4px;\n  font-size: 11px;\n  cursor: pointer;\n  user-select: none;\n  padding: 2px 4px;\n  border-radius: 3px;\n  transition: opacity 0.15s;\n}\n.chart-help .legend-item:hover {\n  background: var(--border);\n}\n.chart-help .legend-item.hidden {\n  opacity: 0.35;\n  text-decoration: line-through;\n}\n.chart-help .legend-dot {\n  width: 10px;\n  height: 3px;\n  border-radius: 1px;\n  display: inline-block;\n  transition: opacity 0.15s;\n}\n.chart-help .insight {\n  background: var(--bg-insight);\n  border-left: 3px solid var(--accent);\n  padding: 6px 10px;\n  margin: 6px 0;\n  border-radius: 0 4px 4px 0;\n  font-size: 12px;\n  color: var(--text);\n  transition: background 0.15s;\n}\n.chart-help .insight[data-highlight]:hover {\n  background: var(--border);\n  cursor: pointer;\n}\n.chart-help .insight.warn {\n  border-left-color: var(--yellow);\n}\n.chart-help .insight.bad {\n  border-left-color: var(--red);\n}\n.chart-help .insight.good {\n  border-left-color: var(--green);\n}\n.chart-help .how-to {\n  color: var(--text-faint);\n  font-size: 11px;\n  margin-top: 6px;\n}\n\n.kw {\n  border-bottom: 1px dotted var(--text-dimmed);\n  cursor: help;\n  position: relative;\n}\n.kw:hover {\n  color: var(--accent);\n  border-bottom-color: var(--accent);\n}\n.kw-tip {\n  display: none;\n  position: fixed;\n  z-index: 999999;\n  background: var(--bg-card);\n  border: 1px solid var(--border);\n  border-radius: 6px;\n  padding: 8px 12px;\n  font-size: 11px;\n  color: var(--text);\n  white-space: normal;\n  width: 260px;\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);\n  line-height: 1.5;\n  pointer-events: none;\n}\n.kw-tip.visible {\n  display: block;\n}\n\n.plot {\n  width: 100%;\n  height: 350px;\n}\n.plot.tall {\n  height: 450px;\n}\n\n.live-status {\n  position: fixed;\n  top: 12px;\n  right: 12px;\n  padding: 6px 14px;\n  border-radius: 6px;\n  font-size: 12px;\n  font-weight: 600;\n  z-index: 1000;\n  border: 1px solid var(--border);\n  background: var(--bg-card);\n}\n.live-status.connected {\n  color: var(--green);\n  border-color: var(--green);\n}\n.live-status.complete {\n  color: var(--accent);\n  border-color: var(--accent);\n}\n.live-status .dot {\n  display: inline-block;\n  width: 8px;\n  height: 8px;\n  border-radius: 50%;\n  margin-right: 6px;\n  animation: pulse 1.5s infinite;\n}\n.live-status.connected .dot {\n  background: var(--green);\n}\n@keyframes pulse {\n  0%, 100% {\n    opacity: 1;\n  }\n  50% {\n    opacity: 0.4;\n  }\n}\n.tab-bar {\n  display: flex;\n  gap: 4px;\n  padding: 0 16px;\n  margin-bottom: 12px;\n  border-bottom: 1px solid var(--border);\n}\n.tab-btn {\n  padding: 8px 16px;\n  border: none;\n  border-bottom: 2px solid transparent;\n  background: none;\n  color: var(--text-muted);\n  font-size: 13px;\n  font-weight: 500;\n  cursor: pointer;\n  transition: color 0.15s, border-color 0.15s;\n}\n.tab-btn:hover {\n  color: var(--text);\n}\n.tab-btn.active {\n  color: var(--accent);\n  border-bottom-color: var(--accent);\n}\n\n.engine-log {\n  font-family: monospace;\n  font-size: 12px;\n  line-height: 1.8;\n  color: var(--text-muted);\n  white-space: pre-wrap;\n}\n.engine-log .log-entry {\n  padding: 2px 0;\n  border-bottom: 1px solid var(--border);\n}\n.engine-log .log-entry:last-child {\n  border-bottom: none;\n}\n.engine-log .log-time {\n  color: var(--text-faint);\n  margin-right: 8px;\n}\n\n.deferred-overlay {\n  position: absolute;\n  inset: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--bg-card);\n  opacity: 0.85;\n  color: var(--text);\n  font-size: 14px;\n  z-index: 10;\n  border-radius: 8px;\n}\n\n@media (max-width: 900px) {\n  .charts {\n    grid-template-columns: 1fr;\n  }\n  .chart.full {\n    grid-template-columns: 1fr;\n  }\n  .chart.full .chart-help {\n    border-left: none;\n    border-top: 1px solid var(--border);\n  }\n}\n";

export const plotly_charts = "// ─── Plotly chart rendering ───\n// Each function renders a chart into a DOM container.\n// Live update functions append data incrementally.\n\nconst plotlyCfg = {\n  displayModeBar: true,\n  responsive: true,\n  modeBarButtonsToRemove: [\"lasso2d\", \"select2d\"],\n};\n\nconst getTheme = () => {\n  const s = getComputedStyle(document.documentElement);\n  return {\n    paper_bgcolor: s.getPropertyValue(\"--bg-card\").trim(),\n    plot_bgcolor: s.getPropertyValue(\"--bg-card\").trim(),\n    font: { color: s.getPropertyValue(\"--text\").trim(), size: 11 },\n    xaxis: {\n      gridcolor: s.getPropertyValue(\"--grid\").trim(),\n      zerolinecolor: s.getPropertyValue(\"--zeroline\").trim(),\n    },\n    yaxis: {\n      gridcolor: s.getPropertyValue(\"--grid\").trim(),\n      zerolinecolor: s.getPropertyValue(\"--zeroline\").trim(),\n    },\n    margin: { l: 50, r: 20, t: 40, b: 40 },\n  };\n};\n\nconst pct = (arr, p) => {\n  if (!arr.length) return 0;\n  const i = p * (arr.length - 1);\n  const lo = Math.floor(i);\n  const hi = Math.ceil(i);\n  return lo === hi ? arr[lo] : arr[lo] + (arr[hi] - arr[lo]) * (i - lo);\n};\n\n// ─── Throughput ───\n\nconst renderThroughput = (D, theme) => {\n  const ws = D.windowSec ?? 1;\n  const traces = [{\n    x: D.windows.map((w) => w.t),\n    y: D.windows.map((w) => w.count / ws),\n    type: \"bar\",\n    marker: { color: \"#238636\" },\n    name: \"req/s\",\n  }];\n  if (D.windows.some((w) => w.errors > 0)) {\n    traces.push({\n      x: D.windows.map((w) => w.t),\n      y: D.windows.map((w) => w.errors / ws),\n      type: \"bar\",\n      marker: { color: \"#da3633\" },\n      name: \"errors/s\",\n    });\n  }\n  Plotly.newPlot(\n    \"throughput\",\n    traces,\n    Object.assign({}, theme, {\n      title: { text: \"Throughput over time\" },\n      xaxis: Object.assign({}, theme.xaxis, { title: { text: \"Time (s)\" } }),\n      yaxis: Object.assign({}, theme.yaxis, { title: { text: \"Requests/s\" } }),\n      barmode: \"overlay\",\n      showlegend: false,\n      shapes: D.concShapes || [],\n      annotations: D.concAnnotations || [],\n    }),\n    plotlyCfg,\n  );\n};\n\n// ─── Latency over time ───\n\nconst renderLatencyTime = (D, theme) => {\n  const scatter = {\n    x: D.events.map((e) => e.t / 1000),\n    y: D.events.map((e) => e.latencyMs),\n    mode: \"markers\",\n    type: \"scatter\",\n    marker: {\n      size: 3,\n      color: D.events.map((e) => e.ok ? \"#58a6ff\" : \"#da3633\"),\n      opacity: 0.4,\n    },\n    name: \"requests\",\n    hovertemplate: \"%{y:.0f}ms at %{x:.1f}s<extra></extra>\",\n  };\n  const p50 = {\n    x: D.windows.map((w) => w.t),\n    y: D.windows.map((w) => w.p50),\n    mode: \"lines\",\n    line: { color: \"#3fb950\", width: 2 },\n    name: \"p50\",\n  };\n  const p95 = {\n    x: D.windows.map((w) => w.t),\n    y: D.windows.map((w) => w.p95),\n    mode: \"lines\",\n    line: { color: \"#d29922\", width: 2 },\n    name: \"p95\",\n  };\n  const p99 = {\n    x: D.windows.map((w) => w.t),\n    y: D.windows.map((w) => w.p99),\n    mode: \"lines\",\n    line: { color: \"#da3633\", width: 2 },\n    name: \"p99\",\n  };\n\n  const shapes = (D.concShapes || []).concat(D.anomalyShapes || []);\n  const annotations = (D.concAnnotations || []).concat(\n    D.anomalyAnnotations || [],\n  );\n\n  Plotly.newPlot(\n    \"latency-time\",\n    [scatter, p50, p95, p99],\n    Object.assign({}, theme, {\n      title: { text: \"Latency over time\" },\n      xaxis: Object.assign({}, theme.xaxis, { title: { text: \"Time (s)\" } }),\n      yaxis: Object.assign({}, theme.yaxis, {\n        title: { text: \"Latency (ms)\" },\n      }),\n      showlegend: false,\n      shapes,\n      annotations,\n    }),\n    plotlyCfg,\n  );\n};\n\n// ─── Histogram ───\n\nconst renderLatencyHist = (D, theme) => {\n  const traces = D.methods.map((m) => ({\n    x: D.events.filter((e) => e.method === m).map((e) => e.latencyMs),\n    type: \"histogram\",\n    name: m,\n    opacity: 0.7,\n    nbinsx: 50,\n  }));\n  Plotly.newPlot(\n    \"latency-hist\",\n    traces,\n    Object.assign({}, theme, {\n      title: { text: \"Latency distribution\" },\n      xaxis: Object.assign({}, theme.xaxis, {\n        title: { text: \"Latency (ms)\" },\n      }),\n      yaxis: Object.assign({}, theme.yaxis, { title: { text: \"Count\" } }),\n      barmode: \"overlay\",\n      showlegend: false,\n    }),\n    plotlyCfg,\n  );\n};\n\n// ─── Box plot ───\n\nconst renderLatencyBox = (D, theme) => {\n  const traces = D.methods.map((m) => ({\n    y: D.events.filter((e) => e.method === m).map((e) => e.latencyMs),\n    type: \"box\",\n    name: m.length > 30 ? `...${m.slice(-30)}` : m,\n    marker: { color: \"#58a6ff\" },\n    boxpoints: false,\n  }));\n  Plotly.newPlot(\n    \"latency-box\",\n    traces,\n    Object.assign({}, theme, {\n      title: { text: \"Latency by method\" },\n      yaxis: Object.assign({}, theme.yaxis, {\n        title: { text: \"Latency (ms)\" },\n      }),\n      showlegend: false,\n    }),\n    plotlyCfg,\n  );\n};\n\n// ─── Concurrency triple-axis ───\n\nconst renderConcurrencyTriple = (D, theme) => {\n  const concTrace = {\n    x: D.windows.map((w) => w.t),\n    y: D.windows.map((w) => w.concurrency),\n    mode: \"lines+markers\",\n    line: { color: \"#bc8cff\", width: 1.5 },\n    marker: { color: \"#bc8cff\", size: 4, opacity: 0.4 },\n    opacity: 0.5,\n    name: \"concurrency\",\n    yaxis: \"y2\",\n  };\n  const ws = D.windowSec ?? 1;\n  const rpsTrace = {\n    x: D.windows.map((w) => w.t),\n    y: D.windows.map((w) => w.count / ws),\n    type: \"bar\",\n    marker: { color: \"#238636\", opacity: 0.5 },\n    name: \"req/s\",\n  };\n  const latTrace = {\n    x: D.windows.map((w) => w.t),\n    y: D.windows.map((w) => w.p50),\n    mode: \"lines\",\n    line: { color: \"#d29922\", width: 2 },\n    name: \"p50 latency\",\n    yaxis: \"y3\",\n  };\n\n  Plotly.newPlot(\n    \"concurrency\",\n    [rpsTrace, concTrace, latTrace],\n    Object.assign({}, theme, {\n      title: { text: \"Concurrency vs Throughput vs Latency\" },\n      xaxis: Object.assign({}, theme.xaxis, {\n        title: { text: \"Time (s)\" },\n        type: \"linear\",\n        domain: [0.05, 0.9],\n      }),\n      yaxis: Object.assign({}, theme.yaxis, {\n        title: { text: \"Requests/s\" },\n        side: \"left\",\n      }),\n      yaxis2: Object.assign({}, theme.yaxis, {\n        title: { text: \"Concurrency\" },\n        overlaying: \"y\",\n        side: \"right\",\n        showgrid: false,\n      }),\n      yaxis3: Object.assign({}, theme.yaxis, {\n        title: { text: \"p50 (ms)\" },\n        overlaying: \"y\",\n        side: \"right\",\n        position: 0.95,\n        showgrid: false,\n      }),\n      showlegend: false,\n      shapes: D.concShapes || [],\n      annotations: D.concAnnotations || [],\n    }),\n    plotlyCfg,\n  );\n};\n\n// ─── Render all charts ───\n\nconst renderAllCharts = (D) => {\n  const theme = getTheme();\n  renderThroughput(D, theme);\n  renderLatencyTime(D, theme);\n  renderLatencyHist(D, theme);\n  renderLatencyBox(D, theme);\n  renderConcurrencyTriple(D, theme);\n};\n\n// ─── Live chart updates ───\n\nconst appendToThroughput = (w) => {\n  const el = document.getElementById(\"throughput\");\n  if (!el || !el.data) return;\n  Plotly.extendTraces(\"throughput\", { x: [[w.t]], y: [[w.count]] }, [0]);\n  if (el.data[1] && w.errors > 0) {\n    Plotly.extendTraces(\"throughput\", { x: [[w.t]], y: [[w.errors]] }, [1]);\n  }\n};\n\n// ─── Re-theme all plots ───\n\nconst plotIds = [\n  \"throughput\",\n  \"latency-time\",\n  \"latency-hist\",\n  \"latency-box\",\n  \"concurrency\",\n];\n\nconst rethemeAll = () => {\n  const theme = getTheme();\n  for (const id of plotIds) {\n    const el = document.getElementById(id);\n    if (el && el.data) {\n      Plotly.relayout(id, {\n        paper_bgcolor: theme.paper_bgcolor,\n        plot_bgcolor: theme.plot_bgcolor,\n        font: theme.font,\n        \"xaxis.gridcolor\": theme.xaxis.gridcolor,\n        \"xaxis.zerolinecolor\": theme.xaxis.zerolinecolor,\n        \"yaxis.gridcolor\": theme.yaxis.gridcolor,\n        \"yaxis.zerolinecolor\": theme.yaxis.zerolinecolor,\n      });\n    }\n  }\n};\n";

export const interactions = "// ─── Save as image ───\n\ndocument.getElementById(\"save-image\").addEventListener(\"click\", function () {\n  const btn = this;\n  btn.disabled = true;\n  btn.textContent = \"Saving...\";\n\n  const actions = document.querySelector(\".header-actions\");\n  const liveStatus = document.querySelector(\".live-status\");\n  actions.style.display = \"none\";\n  if (liveStatus) liveStatus.style.display = \"none\";\n\n  const bg = getComputedStyle(document.documentElement).getPropertyValue(\"--bg\").trim();\n\n  htmlToImage.toPng(document.body, { backgroundColor: bg })\n    .then(function (dataUrl) {\n      const a = document.createElement(\"a\");\n      a.download = \"mcp-stress-\" + new Date().toISOString().replace(/[:.]/g, \"-\").slice(0, 19) + \".png\";\n      a.href = dataUrl;\n      a.click();\n    })\n    .catch(function (err) {\n      console.error(\"Save as image failed:\", err);\n    })\n    .finally(function () {\n      actions.style.display = \"\";\n      if (liveStatus) liveStatus.style.display = \"\";\n      btn.disabled = false;\n      btn.textContent = \"Save as image\";\n    });\n});\n\n// ─── Theme toggle ───\n\nlet isDark = localStorage.getItem(\"mcp-stress-theme\") !== \"light\";\nif (!isDark) {\n  document.documentElement.setAttribute(\"data-theme\", \"light\");\n  document.getElementById(\"theme-toggle\").textContent = \"Dark mode\";\n}\n\ndocument.getElementById(\"theme-toggle\").addEventListener(\"click\", function () {\n  isDark = !isDark;\n  if (isDark) {\n    document.documentElement.removeAttribute(\"data-theme\");\n    this.textContent = \"Light mode\";\n  } else {\n    document.documentElement.setAttribute(\"data-theme\", \"light\");\n    this.textContent = \"Dark mode\";\n  }\n  localStorage.setItem(\"mcp-stress-theme\", isDark ? \"dark\" : \"light\");\n  rethemeAll();\n});\n\n// ─── Keyword glossary ───\n\nconst KW = {\n  \"p50\": {\n    tip:\n      \"50th percentile (median). Half of all requests completed faster than this.\",\n    plot: \"latency-time\",\n    trace: 1,\n    color: \"#3fb950\",\n  },\n  \"p95\": {\n    tip: \"95th percentile. Only 5% of requests were slower than this.\",\n    plot: \"latency-time\",\n    trace: 2,\n    color: \"#d29922\",\n  },\n  \"p99\": {\n    tip:\n      \"99th percentile. Only 1% of requests were slower. This is your worst-case for most users.\",\n    plot: \"latency-time\",\n    trace: 3,\n    color: \"#da3633\",\n  },\n  \"median\": {\n    tip:\n      \"The middle value — 50% of requests are faster, 50% slower. Same as p50.\",\n    plot: \"latency-time\",\n    trace: 1,\n    color: \"#3fb950\",\n  },\n  \"tail latency\": {\n    tip:\n      \"The gap between typical (p50) and worst-case (p99) latency. A long tail means unpredictable performance for some users.\",\n    plot: \"latency-time\",\n    trace: 3,\n    color: \"#da3633\",\n  },\n  \"throughput\": {\n    tip:\n      \"Requests completed per second. Higher is better. Plateaus indicate the server's capacity limit.\",\n    plot: \"throughput\",\n    trace: 0,\n    color: \"#238636\",\n  },\n  \"req/s\": {\n    tip: \"Requests per second — the rate at which the server processes work.\",\n    plot: \"throughput\",\n    trace: 0,\n    color: \"#238636\",\n  },\n  \"concurrency\": {\n    tip:\n      \"Number of simultaneous in-flight requests. Higher concurrency tests how the server handles parallel load.\",\n    plot: \"concurrency\",\n    trace: 1,\n    color: \"#bc8cff\",\n  },\n  \"IQR\": {\n    tip:\n      \"Interquartile Range — the span from p25 to p75, covering the middle 50% of latencies. A narrow IQR means consistent performance; a wide one means high variance.\",\n    plot: \"latency-box\",\n    trace: 0,\n    color: \"#58a6ff\",\n  },\n  \"rolling mean\": {\n    tip:\n      \"Average latency over a sliding 10-second window. Anomalies are detected when p99 exceeds 3x this value.\",\n    plot: \"latency-time\",\n    trace: 1,\n    color: \"#3fb950\",\n  },\n  \"CV\": {\n    tip:\n      \"Coefficient of Variation — standard deviation divided by mean. Below 20% = stable, above 50% = volatile.\",\n    plot: \"throughput\",\n    trace: 0,\n    color: \"#238636\",\n  },\n  \"error rate\": {\n    tip:\n      \"Percentage of requests that returned errors. Any sustained error rate above 1% warrants investigation.\",\n    plot: \"throughput\",\n    trace: 1,\n    color: \"#da3633\",\n  },\n  \"saturation\": {\n    tip:\n      \"The point where adding more concurrency no longer increases throughput — only latency. This is the server's practical limit.\",\n    plot: \"concurrency\",\n    trace: 0,\n    color: \"#238636\",\n  },\n};\n\nconst kw = (word, displayText) => {\n  const entry = KW[word];\n  if (!entry) return displayText || word;\n  const label = displayText || word;\n  return `<span class=\"kw\" data-kw-plot=\"${entry.plot}\" data-kw-trace=\"${entry.trace}\" data-kw-color=\"${entry.color}\">${label}<span class=\"kw-tip\">${entry.tip}</span></span>`;\n};\n\n// ─── Keyword tooltip positioning ───\n\ndocument.addEventListener(\"mouseover\", (e) => {\n  const kwEl = e.target.closest(\".kw\");\n  if (!kwEl) return;\n  const tip = kwEl.querySelector(\".kw-tip\");\n  if (!tip) return;\n  const rect = kwEl.getBoundingClientRect();\n  tip.classList.add(\"visible\");\n  let top = rect.top - tip.offsetHeight - 6;\n  let left = rect.left + rect.width / 2 - tip.offsetWidth / 2;\n  if (top < 4) top = rect.bottom + 6;\n  if (left < 4) left = 4;\n  if (left + tip.offsetWidth > window.innerWidth - 4) {\n    left = window.innerWidth - tip.offsetWidth - 4;\n  }\n  tip.style.top = `${top}px`;\n  tip.style.left = `${left}px`;\n});\n\ndocument.addEventListener(\"mouseout\", (e) => {\n  const kwEl = e.target.closest(\".kw\");\n  if (!kwEl) return;\n  if (kwEl.contains(e.relatedTarget)) return;\n  const tip = kwEl.querySelector(\".kw-tip\");\n  if (tip) tip.classList.remove(\"visible\");\n});\n\n// ─── Keyword hover → highlight trace ───\n\nconst defaultOpacities = {};\n\nconst storeDefaults = (plotId) => {\n  const el = document.getElementById(plotId);\n  if (!el || !el.data || defaultOpacities[plotId]) return;\n  defaultOpacities[plotId] = el.data.map((t) =>\n    t.opacity !== undefined ? t.opacity : 1\n  );\n};\n\ndocument.addEventListener(\"mouseover\", (e) => {\n  const el = e.target.closest(\".kw[data-kw-plot]\");\n  if (!el) return;\n  const plotId = el.getAttribute(\"data-kw-plot\");\n  const traceIdx = parseInt(el.getAttribute(\"data-kw-trace\"));\n  const plotEl = document.getElementById(plotId);\n  if (!plotEl || !plotEl.data || traceIdx >= plotEl.data.length) return;\n  storeDefaults(plotId);\n  el.style.borderBottomColor = el.getAttribute(\"data-kw-color\");\n  for (let i = 0; i < plotEl.data.length; i++) {\n    Plotly.restyle(plotId, { opacity: i === traceIdx ? 1 : 0.08 }, [i]);\n  }\n});\n\ndocument.addEventListener(\"mouseout\", (e) => {\n  const el = e.target.closest(\".kw[data-kw-plot]\");\n  if (!el) return;\n  el.style.borderBottomColor = \"\";\n  const plotId = el.getAttribute(\"data-kw-plot\");\n  const plotEl = document.getElementById(plotId);\n  if (!plotEl || !plotEl.data) return;\n  const defaults = defaultOpacities[plotId] || plotEl.data.map(() => 1);\n  for (let i = 0; i < plotEl.data.length; i++) {\n    Plotly.restyle(plotId, { opacity: defaults[i] }, [i]);\n  }\n});\n\n// ─── Legend toggle ───\n\nconst legendItem = (plotId, traceIndex, color, label) =>\n  `<span class=\"legend-item\" data-plot=\"${plotId}\" data-trace=\"${traceIndex}\"><span class=\"legend-dot\" style=\"background:${color}\"></span> ${label}</span>`;\n\ndocument.addEventListener(\"click\", (e) => {\n  const item = e.target.closest(\".legend-item[data-plot]\");\n  if (!item) return;\n  const plotId = item.getAttribute(\"data-plot\");\n  const traceIdx = parseInt(item.getAttribute(\"data-trace\"));\n  const el = document.getElementById(plotId);\n  if (!el || !el.data || !el.data[traceIdx]) return;\n  const current = el.data[traceIdx].visible;\n  const next = current === \"legendonly\" ? true : \"legendonly\";\n  Plotly.restyle(plotId, { visible: next }, [traceIdx]);\n  item.classList.toggle(\"hidden\", next === \"legendonly\");\n});\n\n// ─── Insight hover → highlight chart region ───\n\nlet activeHighlight = null;\n\ndocument.addEventListener(\"mouseover\", (e) => {\n  const insight = e.target.closest(\".insight[data-highlight]\");\n  if (!insight) return;\n  if (activeHighlight === insight) return;\n  activeHighlight = insight;\n\n  const plotId = insight.getAttribute(\"data-highlight\");\n  const regionStart = parseFloat(\n    insight.getAttribute(\"data-region-start\") || \"0\",\n  );\n  const regionEnd = parseFloat(insight.getAttribute(\"data-region-end\") || \"0\");\n  const traceIdxs = (insight.getAttribute(\"data-traces\") || \"\").split(\",\").map(\n    Number,\n  );\n\n  const el = document.getElementById(plotId);\n  if (!el || !el.data) return;\n  storeDefaults(plotId);\n  for (let i = 0; i < el.data.length; i++) {\n    Plotly.restyle(plotId, { opacity: traceIdxs.indexOf(i) >= 0 ? 1 : 0.15 }, [\n      i,\n    ]);\n  }\n\n  const shapes = (el.layout.shapes || []).filter((s) => !s._isHighlight);\n  shapes.push({\n    type: \"rect\",\n    xref: \"x\",\n    yref: \"paper\",\n    x0: regionStart,\n    x1: regionEnd,\n    y0: 0,\n    y1: 1,\n    fillcolor: \"rgba(88,166,255,0.08)\",\n    line: { color: \"rgba(88,166,255,0.4)\", width: 1 },\n    _isHighlight: true,\n  });\n  Plotly.relayout(plotId, { shapes });\n});\n\ndocument.addEventListener(\"mouseout\", (e) => {\n  const insight = e.target.closest(\".insight[data-highlight]\");\n  if (!insight || !activeHighlight) return;\n  if (insight.contains(e.relatedTarget)) return;\n  activeHighlight = null;\n\n  const plotId = insight.getAttribute(\"data-highlight\");\n  const el = document.getElementById(plotId);\n  if (!el || !el.data) return;\n\n  const defaults = defaultOpacities[plotId] || el.data.map(() => 1);\n  for (let i = 0; i < el.data.length; i++) {\n    Plotly.restyle(plotId, { opacity: defaults[i] }, [i]);\n  }\n  const shapes = (el.layout.shapes || []).filter((s) => !s._isHighlight);\n  Plotly.relayout(plotId, { shapes });\n});\n\n// ─── Copy repro command ───\n\ndocument.addEventListener(\"click\", (e) => {\n  const repro = e.target.closest(\"#repro-cmd\");\n  if (!repro) return;\n  const hint = document.getElementById(\"repro-hint\");\n  if (!hint) return;\n  const text = repro.textContent.replace(hint.textContent, \"\").trim();\n  navigator.clipboard.writeText(text).then(() => {\n    hint.textContent = \"copied!\";\n    hint.classList.add(\"copied\");\n    setTimeout(() => {\n      hint.textContent = \"click to copy\";\n      hint.classList.remove(\"copied\");\n    }, 2000);\n  });\n});\n";

export const insights = "// ─── Data-driven insights ───\n// Analyzes computed data and generates HTML for help panels.\n\nconst stat = (v, l) =>\n  `<div class=\"stat\"><div class=\"value\">${v}</div><div class=\"label\">${l}</div></div>`;\n\nconst kv = (k, v) => `<dt>${k}</dt><dd>${v}</dd>`;\n\nconst renderHeader = (D) => {\n  const { meta } = D;\n  const parts = [];\n  if (meta) {\n    parts.push(meta.profile);\n    parts.push(`${D.totalRequests} requests over ${D.durationSec.toFixed(1)}s`);\n    parts.push(meta.startedAt);\n    parts.push(`${meta.transport}: ${meta.target}`);\n  } else {\n    parts.push(`${D.totalRequests} requests over ${D.durationSec.toFixed(1)}s`);\n  }\n  document.getElementById(\"meta\").textContent = parts.join(\" | \");\n};\n\nconst renderStats = (D) => {\n  const rps = D.totalRequests / D.durationSec;\n  const errRate = D.totalErrors / D.totalRequests * 100;\n  const errClass = errRate > 5 ? \"bad\" : errRate > 1 ? \"warn\" : \"\";\n  document.getElementById(\"stats\").innerHTML =\n    stat(rps.toFixed(1), \"avg req/s\") +\n    stat(D.totalRequests, \"total requests\") +\n    stat(`${D.overallP50.toFixed(0)}ms`, \"p50 latency\") +\n    stat(`${D.overallP95.toFixed(0)}ms`, \"p95 latency\") +\n    stat(`${D.overallP99.toFixed(0)}ms`, \"p99 latency\") +\n    stat(`${D.overallMin.toFixed(0)}ms`, \"min\") +\n    stat(`${D.overallMax.toFixed(0)}ms`, \"max\") +\n    `<div class=\"stat\"><div class=\"value ${errClass}\">${\n      errRate.toFixed(1)\n    }%</div><div class=\"label\">error rate</div></div>`;\n};\n\nconst renderRunParams = (D) => {\n  const { meta } = D;\n  let html = '<h2>Run parameters</h2><dl class=\"params\">';\n  if (meta) {\n    html += kv(\"Profile\", meta.profile);\n    html += kv(\"Duration\", `${meta.durationSec}s`);\n    html += kv(\"Concurrency\", meta.concurrency);\n    if (meta.shape) html += kv(\"Shape\", meta.shape);\n    if (meta.tool) html += kv(\"Tool\", meta.tool);\n    html += kv(\"Timeout\", `${meta.timeoutMs}ms`);\n    html += kv(\"Transport\", meta.transport);\n    html += kv(\"Target\", meta.target);\n    if (meta.seed !== undefined) html += kv(\"Seed\", meta.seed);\n    html += kv(\"Started\", meta.startedAt);\n  }\n  html += \"</dl>\";\n  if (meta && meta.command) {\n    html +=\n      `<div class=\"repro\" id=\"repro-cmd\">${meta.command}<span class=\"repro-hint\" id=\"repro-hint\">click to copy</span></div>`;\n  }\n  document.getElementById(\"run-params\").innerHTML = html;\n};\n\nconst renderThroughputHelp = (D) => {\n  const ws = D.windowSec ?? 1;\n  const rpsValues = D.windows.map((w) => w.count / ws);\n  const peakRps = Math.max(...rpsValues);\n  const avgRps = rpsValues.reduce((a, b) => a + b, 0) / rpsValues.length;\n  const rpsVariance = rpsValues.reduce((s, v) => s + (v - avgRps) ** 2, 0) /\n    rpsValues.length;\n  const rpsCV = avgRps > 0 ? Math.sqrt(rpsVariance) / avgRps : 0;\n\n  let html = '<span class=\"title\">Throughput over time</span>';\n  html += '<div class=\"legend\">';\n  html += legendItem(\"throughput\", 0, \"#238636\", \"requests/sec\");\n  if (D.windows.some((w) => w.errors > 0)) {\n    html += legendItem(\"throughput\", 1, \"#da3633\", \"errors/sec\");\n  }\n  html += \"</div>\";\n\n  html += `<div class=\"insight ${\n    rpsCV < 0.3 ? \"good\" : rpsCV < 0.6 ? \"warn\" : \"bad\"\n  }\">`;\n  html += `Peak: <strong>${peakRps.toFixed(1)} ${\n    kw(\"req/s\")\n  }</strong>, avg: <strong>${avgRps.toFixed(1)} ${kw(\"req/s\")}</strong>. `;\n  if (rpsCV < 0.2) {\n    html += `Very stable ${kw(\"throughput\")} (${kw(\"CV\")}=${\n      (rpsCV * 100).toFixed(0)\n    }%).`;\n  } else if (rpsCV < 0.5) {\n    html += `Moderate variation (${kw(\"CV\")}=${(rpsCV * 100).toFixed(0)}%).`;\n  } else {\n    html += `High variation (${kw(\"CV\")}=${\n      (rpsCV * 100).toFixed(0)\n    }%) — check for queueing, GC pauses, or rate limiting.`;\n  }\n  html += \"</div>\";\n  if (D.totalErrors > 0) {\n    html += `<div class=\"insight bad\">${kw(\"error rate\", \"Error rate\")}: ${\n      (D.totalErrors / D.totalRequests * 100).toFixed(1)\n    }%.</div>`;\n  }\n  const wLabel = ws >= 60 ? `${ws / 60} minute` : `${ws} second`;\n  html +=\n    `<div class=\"how-to\">Each bar = ${wLabel} window. Drag to zoom, double-click to reset.</div>`;\n  document.getElementById(\"help-throughput\").innerHTML = html;\n};\n\nconst renderLatencyTimeHelp = (D) => {\n  const p99p50ratio = D.overallP99 / Math.max(D.overallP50, 1);\n\n  let html = '<span class=\"title\">Latency over time</span>';\n  html += '<div class=\"legend\">';\n  html += legendItem(\"latency-time\", 0, \"#58a6ff\", \"requests\");\n  html += legendItem(\"latency-time\", 1, \"#3fb950\", \"p50\");\n  html += legendItem(\"latency-time\", 2, \"#d29922\", \"p95\");\n  html += legendItem(\"latency-time\", 3, \"#da3633\", \"p99\");\n  html += \"</div>\";\n\n  html += `<div class=\"insight ${\n    p99p50ratio < 2 ? \"good\" : p99p50ratio < 5 ? \"warn\" : \"bad\"\n  }\">`;\n  html += `${kw(\"p50\")}=${D.overallP50.toFixed(0)}ms, ${kw(\"p99\")}=${\n    D.overallP99.toFixed(0)\n  }ms (ratio: ${p99p50ratio.toFixed(1)}x). `;\n  if (p99p50ratio < 2) {\n    html += \"Tight tail — predictable performance.\";\n  } else if (p99p50ratio < 5) {\n    html += `Noticeable ${kw(\"tail latency\")} — typical under load.`;\n  } else {\n    html += `Very long ${kw(\"tail latency\")} — investigate outliers.`;\n  }\n  html += \"</div>\";\n\n  // Latency drift detection\n  if (D.windows.length >= 4) {\n    const q = Math.floor(D.windows.length / 4);\n    const firstQuarter = D.windows.slice(0, q);\n    const lastQuarter = D.windows.slice(q * 3);\n    const firstP50 = firstQuarter.reduce((s, w) => s + w.p50, 0) /\n      firstQuarter.length;\n    const lastP50 = lastQuarter.reduce((s, w) => s + w.p50, 0) /\n      lastQuarter.length;\n    const drift = (lastP50 - firstP50) / Math.max(firstP50, 1);\n    const q1End = D.windows[q]?.t ?? 0;\n    const q3Start = D.windows[q * 3]?.t ?? 0;\n    const lastT = D.windows[D.windows.length - 1]?.t ?? 0;\n    if (drift > 0.3) {\n      html +=\n        `<div class=\"insight warn\" data-highlight=\"latency-time\" data-traces=\"1\" data-region-start=\"${q3Start}\" data-region-end=\"${lastT}\">Latency drift: ${\n          kw(\"p50\")\n        } increased ${\n          (drift * 100).toFixed(0)\n        }% from first to last quarter.</div>`;\n    } else if (drift < -0.2) {\n      html +=\n        `<div class=\"insight good\" data-highlight=\"latency-time\" data-traces=\"1\" data-region-start=\"0\" data-region-end=\"${q1End}\">Latency improved ${\n          (Math.abs(drift) * 100).toFixed(0)\n        }% — server warmed up.</div>`;\n    }\n  }\n\n  // Anomalies\n  if (D.anomalies && D.anomalies.length > 0) {\n    html +=\n      `<div style=\"margin-top:8px\"><strong style=\"color:var(--text-heading);font-size:12px\">Anomalies (${D.anomalies.length})</strong>`;\n    const shown = D.anomalies.slice(0, 5);\n    for (const a of shown) {\n      html +=\n        `<div class=\"insight warn\" style=\"font-size:11px;padding:4px 8px;margin:3px 0\" data-highlight=\"latency-time\" data-traces=\"3\" data-region-start=\"${\n          a.t - 2\n        }\" data-region-end=\"${a.t + 2}\">`;\n      html += `<strong>t=${a.t.toFixed(0)}s</strong> ${kw(\"p99\")}=${\n        a.latencyMs.toFixed(0)\n      }ms (${(a.latencyMs / a.rollingMean).toFixed(1)}x ${kw(\"rolling mean\")})`;\n      html += \"</div>\";\n    }\n    if (D.anomalies.length > 5) {\n      html += `<div style=\"font-size:11px;color:var(--text-faint)\">...and ${\n        D.anomalies.length - 5\n      } more</div>`;\n    }\n    html += \"</div>\";\n  }\n  html +=\n    '<div class=\"how-to\">Drag to zoom into a region. Double-click to reset.</div>';\n  document.getElementById(\"help-latency-time\").innerHTML = html;\n};\n\nconst renderHistHelp = (D) => {\n  const allLat = D.events.map((e) => e.latencyMs).sort((a, b) => a - b);\n  const iqr = pct(allLat, 0.75) - pct(allLat, 0.25);\n  const skew = (D.overallMean - D.overallP50) / Math.max(iqr, 1);\n\n  let html = '<span class=\"title\">Latency distribution</span>';\n  html += `<div class=\"insight ${Math.abs(skew) < 0.5 ? \"good\" : \"warn\"}\">`;\n  html += `Range: ${D.overallMin.toFixed(0)}–${D.overallMax.toFixed(0)}ms. ${\n    kw(\"IQR\", \"IQR (middle 50%)\")\n  }: ${iqr.toFixed(0)}ms. `;\n  if (Math.abs(skew) < 0.3) {\n    html += \"Symmetric distribution.\";\n  } else if (skew > 0) {\n    html += \"Right-skewed — a minority of requests are significantly slower.\";\n  } else {\n    html += \"Left-skewed — unusual.\";\n  }\n  html += \"</div>\";\n  document.getElementById(\"help-latency-hist\").innerHTML = html;\n};\n\nconst renderBoxHelp = (D) => {\n  let html = '<span class=\"title\">Latency by method</span>';\n  if (D.methods.length === 1) {\n    html += `<div class=\"insight\">Single method (${\n      D.methods[0]\n    }). Box shows p25–p75, line = median, whiskers = p5–p95.</div>`;\n  } else {\n    html +=\n      `<div class=\"insight\">Comparing ${D.methods.length} methods. Look for boxes at different heights.</div>`;\n  }\n  document.getElementById(\"help-latency-box\").innerHTML = html;\n};\n\nconst renderConcurrencyHelp = (D) => {\n  const el = document.getElementById(\"help-concurrency\");\n  if (!el) return;\n\n  let html = '<span class=\"title\">Concurrency vs Throughput vs Latency</span>';\n  html += '<div class=\"legend\">';\n  html += legendItem(\"concurrency\", 0, \"#238636\", \"throughput (req/s)\");\n  html += legendItem(\"concurrency\", 1, \"#bc8cff\", \"concurrency\");\n  html += legendItem(\"concurrency\", 2, \"#d29922\", \"p50 latency\");\n  html += \"</div>\";\n\n  const peakWindow = D.windows.reduce(\n    (best, w) => w.count > best.count ? w : best,\n    D.windows[0],\n  );\n  html += `<div class=\"insight\">Peak ${\n    kw(\"throughput\")\n  }: <strong>${peakWindow.count} ${kw(\"req/s\")}</strong> at ${\n    kw(\"concurrency\")\n  } <strong>${peakWindow.concurrency || \"?\"}</strong> (t=${\n    peakWindow.t.toFixed(0)\n  }s). `;\n\n  if (D.concChanges && D.concChanges.length >= 2) {\n    const lastChange = D.concChanges[D.concChanges.length - 1];\n    const prevChange = D.concChanges[D.concChanges.length - 2];\n    const windowsAtLast = D.windows.filter((w) =>\n      w.concurrency === lastChange.to\n    );\n    const windowsAtPrev = D.windows.filter((w) =>\n      w.concurrency === prevChange.to\n    );\n    if (windowsAtLast.length && windowsAtPrev.length) {\n      const rpsLast = windowsAtLast.reduce((s, w) => s + w.count, 0) /\n        windowsAtLast.length;\n      const rpsPrev = windowsAtPrev.reduce((s, w) => s + w.count, 0) /\n        windowsAtPrev.length;\n      const latLast = windowsAtLast.reduce((s, w) => s + w.p50, 0) /\n        windowsAtLast.length;\n      const latPrev = windowsAtPrev.reduce((s, w) => s + w.p50, 0) /\n        windowsAtPrev.length;\n      if (rpsLast <= rpsPrev * 1.1 && latLast > latPrev * 1.2) {\n        html += `${\n          kw(\"saturation\", \"Saturation\")\n        } point around c=${prevChange.to}.`;\n      } else {\n        html += `Throughput still scaling at c=${lastChange.to}.`;\n      }\n    }\n  }\n  html += \"</div>\";\n  html +=\n    '<div class=\"how-to\">Three y-axes: left = req/s, right = concurrency + latency.</div>';\n  el.innerHTML = html;\n};\n\nconst renderAllInsights = (D) => {\n  renderHeader(D);\n  renderStats(D);\n  renderRunParams(D);\n  renderThroughputHelp(D);\n  renderLatencyTimeHelp(D);\n  renderHistHelp(D);\n  renderBoxHelp(D);\n  renderConcurrencyHelp(D);\n};\n";

export const live = "// ─── Live SSE client ───\n// Connects to /events endpoint, streams window stats in real-time.\n// On 'complete' event, receives full PreparedData and re-renders.\n// Individual request events are NOT streamed — only 1-second window aggregates.\n//\n// For --repeat runs, handles multiple sequential runs with tabs:\n// - 'new-run' creates a new tab for each run\n// - 'run-complete' stores PreparedData per run\n// - 'all-complete' adds an Aggregate tab and closes SSE\n\n(() => {\n  const statusEl = document.createElement(\"div\");\n  statusEl.className = \"live-status connected\";\n  statusEl.innerHTML = '<span class=\"dot\"></span>Live';\n  document.body.appendChild(statusEl);\n\n  // All charts except throughput are deferred until test completes\n  const deferredIds = [\n    \"latency-time\",\n    \"latency-hist\",\n    \"latency-box\",\n    \"concurrency\",\n  ];\n\n  function addDeferredOverlays() {\n    for (const id of deferredIds) {\n      const plotEl = document.getElementById(id);\n      if (!plotEl) continue;\n      const chart = plotEl.closest(\".chart\");\n      // Remove existing overlay if any\n      const existing = chart.querySelector(\".deferred-overlay\");\n      if (existing) continue;\n      chart.style.position = \"relative\";\n      const overlay = document.createElement(\"div\");\n      overlay.className = \"deferred-overlay\";\n      overlay.textContent = \"Available after test completes\";\n      chart.appendChild(overlay);\n    }\n  }\n\n  function removeDeferredOverlays() {\n    for (const overlay of document.querySelectorAll(\".deferred-overlay\")) {\n      overlay.remove();\n    }\n  }\n\n  addDeferredOverlays();\n\n  // ─── State ────────────────────────────────────────────────────\n  // For single runs, runs stays empty and we use the flat liveWindows/liveMeta.\n  // For multi-run (--repeat), each run gets its own entry in runs[].\n\n  const runs = [];        // [{index, windows, meta, prepared?}]\n  let activeRunIndex = -1;\n  let totalRuns = 1;\n  let isMultiRun = false;\n\n  // Flat state for single-run mode (or the currently active run in multi-run)\n  let liveWindows = [];\n  let liveMeta = null;\n  let reconnectDelay = 500;\n  let tabBar = null;\n\n  const buildLiveData = (windows, meta) => {\n    let totalRequests = 0;\n    let totalErrors = 0;\n    let maxT = 0;\n    const p50s = [];\n    const p95s = [];\n    const p99s = [];\n\n    for (const w of windows) {\n      totalRequests += w.count;\n      totalErrors += w.errors;\n      if (w.t > maxT) maxT = w.t;\n      p50s.push(w.p50);\n      p95s.push(w.p95);\n      p99s.push(w.p99);\n    }\n\n    p50s.sort((a, b) => a - b);\n    p95s.sort((a, b) => a - b);\n    p99s.sort((a, b) => a - b);\n\n    return {\n      events: [],\n      windows: windows,\n      methods: [],\n      meta: meta,\n      hasConcurrency: windows.some((w) => w.concurrency !== undefined),\n      totalRequests,\n      totalErrors,\n      durationSec: maxT + 1,\n      overallP50: pct(p50s, 0.5),\n      overallP95: pct(p95s, 0.5),\n      overallP99: pct(p99s, 0.5),\n      overallMean: 0,\n      overallMin: p50s.length > 0 ? p50s[0] : 0,\n      overallMax: p99s.length > 0 ? p99s[p99s.length - 1] : 0,\n      concChanges: [],\n      concShapes: [],\n      concAnnotations: [],\n      anomalies: [],\n      anomalyShapes: [],\n      anomalyAnnotations: [],\n    };\n  };\n\n  // ─── Tab bar ──────────────────────────────────────────────────\n\n  function ensureTabBar() {\n    if (tabBar) return;\n    tabBar = document.createElement(\"div\");\n    tabBar.className = \"tab-bar\";\n    const charts = document.querySelector(\".charts\");\n    charts.parentNode.insertBefore(tabBar, charts);\n  }\n\n  function addTab(label, index) {\n    ensureTabBar();\n    const btn = document.createElement(\"button\");\n    btn.className = \"tab-btn\";\n    btn.textContent = label;\n    btn.dataset.runIndex = index;\n    btn.addEventListener(\"click\", () => switchToTab(index));\n    tabBar.appendChild(btn);\n  }\n\n  function switchToTab(index) {\n    activeRunIndex = index;\n    // Update active tab styling\n    for (const btn of tabBar.querySelectorAll(\".tab-btn\")) {\n      btn.classList.toggle(\"active\", parseInt(btn.dataset.runIndex) === index);\n    }\n    // Render the tab's data\n    const run = runs.find((r) => r.index === index);\n    if (!run) return;\n\n    if (run.prepared) {\n      removeDeferredOverlays();\n      renderAllCharts(run.prepared);\n      renderAllInsights(run.prepared);\n      renderHeader(run.prepared);\n      renderRunParams(run.prepared);\n    } else {\n      addDeferredOverlays();\n      const liveD = buildLiveData(run.windows, run.meta);\n      const theme = getTheme();\n      renderThroughput(liveD, theme);\n      renderAllInsights(liveD);\n      renderHeader(liveD);\n      renderRunParams(liveD);\n    }\n  }\n\n  // ─── SSE connection ───────────────────────────────────────────\n\n  const connect = () => {\n    const source = new EventSource(\"/events\");\n\n    source.onopen = () => {\n      reconnectDelay = 500;\n      statusEl.className = \"live-status connected\";\n      statusEl.innerHTML = '<span class=\"dot\"></span>Live';\n    };\n\n    source.addEventListener(\"window\", (e) => {\n      const w = JSON.parse(e.data);\n\n      if (isMultiRun) {\n        // Append to the active run's windows\n        const run = runs.find((r) => r.index === activeRunIndex);\n        if (run) run.windows.push(w);\n        // Only render if this tab is active\n        liveWindows = run ? run.windows : liveWindows;\n      } else {\n        liveWindows.push(w);\n      }\n\n      const liveD = buildLiveData(liveWindows, liveMeta);\n\n      if (liveWindows.length === 1) {\n        const theme = getTheme();\n        renderThroughput(liveD, theme);\n        renderAllInsights(liveD);\n      } else {\n        appendToThroughput(w);\n        if (liveWindows.length % 5 === 0) {\n          renderAllInsights(liveD);\n        }\n      }\n    });\n\n    source.addEventListener(\"meta\", (e) => {\n      liveMeta = JSON.parse(e.data);\n\n      if (isMultiRun) {\n        const run = runs.find((r) => r.index === activeRunIndex);\n        if (run) run.meta = liveMeta;\n      }\n\n      const liveD = buildLiveData(liveWindows, liveMeta);\n      renderHeader(liveD);\n      renderRunParams(liveD);\n    });\n\n    source.addEventListener(\"message\", (e) => {\n      const { text } = JSON.parse(e.data);\n      const logEl = document.getElementById(\"engine-log\");\n      logEl.style.display = \"\";\n      const entry = document.createElement(\"div\");\n      entry.className = \"log-entry\";\n      entry.textContent = text;\n      logEl.appendChild(entry);\n    });\n\n    // ─── Single-run complete ──────────────────────────────────\n\n    source.addEventListener(\"complete\", (e) => {\n      const prepared = JSON.parse(e.data);\n      source.close();\n\n      statusEl.className = \"live-status complete\";\n      statusEl.innerHTML = \"Complete — page is now self-contained\";\n      setTimeout(() => {\n        statusEl.style.display = \"none\";\n      }, 10000);\n\n      // Embed PreparedData for page persistence (save-as works)\n      const scriptEl = document.createElement(\"script\");\n      scriptEl.id = \"embedded-data\";\n      scriptEl.textContent = `var D = ${JSON.stringify(prepared)};`;\n      document.head.appendChild(scriptEl);\n      window.D = prepared;\n\n      removeDeferredOverlays();\n      renderAllCharts(prepared);\n      renderAllInsights(prepared);\n    });\n\n    // ─── Multi-run events ─────────────────────────────────────\n\n    source.addEventListener(\"new-run\", (e) => {\n      const { index, total } = JSON.parse(e.data);\n      isMultiRun = true;\n      totalRuns = total;\n\n      const run = { index, windows: [], meta: null, prepared: null };\n      runs.push(run);\n      activeRunIndex = index;\n      liveWindows = run.windows;\n      liveMeta = null;\n\n      addTab(`Run ${index}`, index);\n      switchToTab(index);\n\n      addDeferredOverlays();\n\n      statusEl.className = \"live-status connected\";\n      statusEl.innerHTML = `<span class=\"dot\"></span>Run ${index}/${total}`;\n    });\n\n    source.addEventListener(\"run-complete\", (e) => {\n      const { index, prepared } = JSON.parse(e.data);\n      const run = runs.find((r) => r.index === index);\n      if (run) {\n        run.prepared = prepared;\n      }\n      // If this tab is active, render it fully\n      if (activeRunIndex === index) {\n        removeDeferredOverlays();\n        renderAllCharts(prepared);\n        renderAllInsights(prepared);\n      }\n    });\n\n    source.addEventListener(\"all-complete\", (e) => {\n      const { summary } = JSON.parse(e.data);\n      source.close();\n\n      // Add aggregate tab\n      const aggIndex = -1; // special index for aggregate\n      runs.push({\n        index: aggIndex,\n        windows: [],\n        meta: null,\n        // Build a minimal prepared-like object from the aggregate summary\n        prepared: {\n          events: [],\n          windows: [],\n          methods: [],\n          meta: { profile: \"Aggregate\", aggregate: true, runCount: totalRuns },\n          hasConcurrency: false,\n          totalRequests: summary.totalRequests,\n          totalErrors: summary.totalErrors,\n          durationSec: summary.durationMs / 1000,\n          overallP50: summary.overall.p50,\n          overallP95: summary.overall.p95,\n          overallP99: summary.overall.p99,\n          overallMean: summary.overall.mean,\n          overallMin: summary.overall.min,\n          overallMax: summary.overall.max,\n          concChanges: [],\n          concShapes: [],\n          concAnnotations: [],\n          anomalies: [],\n          anomalyShapes: [],\n          anomalyAnnotations: [],\n          windowSec: 1,\n        },\n      });\n      addTab(\"Aggregate\", aggIndex);\n\n      statusEl.className = \"live-status complete\";\n      statusEl.innerHTML = `Complete — ${totalRuns} runs`;\n      setTimeout(() => {\n        statusEl.style.display = \"none\";\n      }, 10000);\n\n      // Embed last active run's data for page persistence\n      const lastRun = runs.find((r) => r.index === activeRunIndex);\n      if (lastRun && lastRun.prepared) {\n        const scriptEl = document.createElement(\"script\");\n        scriptEl.id = \"embedded-data\";\n        scriptEl.textContent = `var D = ${JSON.stringify(lastRun.prepared)};`;\n        document.head.appendChild(scriptEl);\n        window.D = lastRun.prepared;\n      }\n    });\n\n    source.onerror = () => {\n      source.close();\n      statusEl.className = \"live-status\";\n      statusEl.innerHTML = \"Reconnecting...\";\n      statusEl.style.color = \"var(--yellow)\";\n      setTimeout(() => {\n        reconnectDelay = Math.min(reconnectDelay * 2, 5000);\n        connect();\n      }, reconnectDelay);\n    };\n  };\n\n  connect();\n})();\n";

export const compare = "// ─── Comparison mode ───\n// Renders overlaid charts from D_BASELINE and D_CURRENT datasets.\n\n(() => {\n  const section = document.getElementById(\"compare-section\");\n  if (!section) return;\n  section.style.display = \"\";\n\n  // Hide the standard single-run charts\n  document.querySelector(\".charts\").style.display = \"none\";\n\n  const theme = getTheme();\n\n  // ─── Summary diff table ───\n  const metrics = [\n    {\n      name: \"p50\",\n      unit: \"ms\",\n      b: D_BASELINE.overallP50,\n      c: D_CURRENT.overallP50,\n      higher_is_worse: true,\n    },\n    {\n      name: \"p95\",\n      unit: \"ms\",\n      b: D_BASELINE.overallP95,\n      c: D_CURRENT.overallP95,\n      higher_is_worse: true,\n    },\n    {\n      name: \"p99\",\n      unit: \"ms\",\n      b: D_BASELINE.overallP99,\n      c: D_CURRENT.overallP99,\n      higher_is_worse: true,\n    },\n    {\n      name: \"rps\",\n      unit: \"\",\n      b: D_BASELINE.totalRequests / D_BASELINE.durationSec,\n      c: D_CURRENT.totalRequests / D_CURRENT.durationSec,\n      higher_is_worse: false,\n    },\n    {\n      name: \"error_rate\",\n      unit: \"%\",\n      b: D_BASELINE.totalErrors / D_BASELINE.totalRequests * 100,\n      c: D_CURRENT.totalErrors / D_CURRENT.totalRequests * 100,\n      higher_is_worse: true,\n    },\n  ];\n\n  let tableHtml = '<div class=\"section\"><h2>Comparison Summary</h2>';\n  tableHtml +=\n    '<table style=\"width:100%;border-collapse:collapse;font-size:13px;margin-top:8px\">';\n  tableHtml += '<tr style=\"border-bottom:1px solid var(--border)\">';\n  tableHtml +=\n    '<th style=\"text-align:left;padding:6px 12px;color:var(--text-muted)\">Metric</th>';\n  tableHtml +=\n    '<th style=\"text-align:right;padding:6px 12px;color:var(--text-muted)\">Baseline</th>';\n  tableHtml +=\n    '<th style=\"text-align:right;padding:6px 12px;color:var(--text-muted)\">Current</th>';\n  tableHtml +=\n    '<th style=\"text-align:right;padding:6px 12px;color:var(--text-muted)\">Delta</th>';\n  tableHtml +=\n    '<th style=\"text-align:left;padding:6px 12px;color:var(--text-muted)\">Status</th>';\n  tableHtml += \"</tr>\";\n\n  for (const m of metrics) {\n    const delta = m.c - m.b;\n    const deltaPct = m.b !== 0 ? (delta / m.b * 100) : 0;\n    const isWorse = m.higher_is_worse ? delta > 0 : delta < 0;\n    const statusColor = Math.abs(deltaPct) < 2\n      ? \"var(--text-muted)\"\n      : isWorse\n      ? \"var(--red)\"\n      : \"var(--green)\";\n    const statusText = Math.abs(deltaPct) < 2\n      ? \"\\u2014\"\n      : isWorse\n      ? \"\\u25B2 worse\"\n      : \"\\u25BC better\";\n\n    tableHtml += '<tr style=\"border-bottom:1px solid var(--border)\">';\n    tableHtml += `<td style=\"padding:6px 12px;font-weight:600\">${m.name}</td>`;\n    tableHtml += `<td style=\"text-align:right;padding:6px 12px\">${\n      m.b.toFixed(1)\n    }${m.unit}</td>`;\n    tableHtml += `<td style=\"text-align:right;padding:6px 12px\">${\n      m.c.toFixed(1)\n    }${m.unit}</td>`;\n    tableHtml +=\n      `<td style=\"text-align:right;padding:6px 12px;color:${statusColor}\">${\n        deltaPct >= 0 ? \"+\" : \"\"\n      }${deltaPct.toFixed(1)}%</td>`;\n    tableHtml +=\n      `<td style=\"padding:6px 12px;color:${statusColor}\">${statusText}</td>`;\n    tableHtml += \"</tr>\";\n  }\n  tableHtml += \"</table></div>\";\n\n  // ─── Chart containers ───\n  tableHtml += '<div class=\"charts\">';\n  tableHtml +=\n    '<div class=\"chart full\"><div id=\"cmp-throughput\" class=\"plot\"></div><div class=\"chart-help\"><span class=\"title\">Throughput Comparison</span><div class=\"legend\">' +\n    '<span class=\"legend-item\"><span class=\"legend-dot\" style=\"background:#238636;opacity:0.5\"></span> baseline</span>' +\n    '<span class=\"legend-item\"><span class=\"legend-dot\" style=\"background:#58a6ff\"></span> current</span>' +\n    \"</div></div></div>\";\n  tableHtml +=\n    '<div class=\"chart full\"><div id=\"cmp-latency\" class=\"plot tall\"></div><div class=\"chart-help\"><span class=\"title\">Latency Comparison</span><div class=\"legend\">' +\n    '<span class=\"legend-item\"><span class=\"legend-dot\" style=\"background:#3fb950;opacity:0.4\"></span> baseline p50</span>' +\n    '<span class=\"legend-item\"><span class=\"legend-dot\" style=\"background:#3fb950\"></span> current p50</span>' +\n    '<span class=\"legend-item\"><span class=\"legend-dot\" style=\"background:#da3633;opacity:0.4\"></span> baseline p99</span>' +\n    '<span class=\"legend-item\"><span class=\"legend-dot\" style=\"background:#da3633\"></span> current p99</span>' +\n    \"</div></div></div>\";\n  tableHtml +=\n    '<div class=\"chart\"><div id=\"cmp-hist\" class=\"plot\"></div><div class=\"chart-help\"><span class=\"title\">Latency Distribution</span></div></div>';\n  tableHtml +=\n    '<div class=\"chart\"><div id=\"cmp-box\" class=\"plot\"></div><div class=\"chart-help\"><span class=\"title\">Latency Box Plot</span></div></div>';\n  tableHtml += \"</div>\";\n\n  section.innerHTML = tableHtml;\n\n  // ─── Overlaid throughput ───\n  Plotly.newPlot(\n    \"cmp-throughput\",\n    [\n      {\n        x: D_BASELINE.windows.map((w) => w.t),\n        y: D_BASELINE.windows.map((w) => w.count),\n        type: \"bar\",\n        marker: { color: \"#238636\", opacity: 0.4 },\n        name: \"baseline req/s\",\n      },\n      {\n        x: D_CURRENT.windows.map((w) => w.t),\n        y: D_CURRENT.windows.map((w) => w.count),\n        type: \"bar\",\n        marker: { color: \"#58a6ff\", opacity: 0.7 },\n        name: \"current req/s\",\n      },\n    ],\n    Object.assign({}, theme, {\n      title: { text: \"Throughput comparison\" },\n      xaxis: Object.assign({}, theme.xaxis, { title: { text: \"Time (s)\" } }),\n      yaxis: Object.assign({}, theme.yaxis, { title: { text: \"Requests/s\" } }),\n      barmode: \"overlay\",\n      showlegend: false,\n    }),\n    plotlyCfg,\n  );\n\n  // ─── Overlaid latency ───\n  Plotly.newPlot(\n    \"cmp-latency\",\n    [\n      {\n        x: D_BASELINE.windows.map((w) => w.t),\n        y: D_BASELINE.windows.map((w) => w.p50),\n        mode: \"lines\",\n        line: { color: \"#3fb950\", width: 1, dash: \"dash\" },\n        name: \"baseline p50\",\n        opacity: 0.5,\n      },\n      {\n        x: D_CURRENT.windows.map((w) => w.t),\n        y: D_CURRENT.windows.map((w) => w.p50),\n        mode: \"lines\",\n        line: { color: \"#3fb950\", width: 2 },\n        name: \"current p50\",\n      },\n      {\n        x: D_BASELINE.windows.map((w) => w.t),\n        y: D_BASELINE.windows.map((w) => w.p99),\n        mode: \"lines\",\n        line: { color: \"#da3633\", width: 1, dash: \"dash\" },\n        name: \"baseline p99\",\n        opacity: 0.5,\n      },\n      {\n        x: D_CURRENT.windows.map((w) => w.t),\n        y: D_CURRENT.windows.map((w) => w.p99),\n        mode: \"lines\",\n        line: { color: \"#da3633\", width: 2 },\n        name: \"current p99\",\n      },\n    ],\n    Object.assign({}, theme, {\n      title: { text: \"Latency comparison\" },\n      xaxis: Object.assign({}, theme.xaxis, { title: { text: \"Time (s)\" } }),\n      yaxis: Object.assign({}, theme.yaxis, {\n        title: { text: \"Latency (ms)\" },\n      }),\n      showlegend: false,\n    }),\n    plotlyCfg,\n  );\n\n  // ─── Overlaid histogram ───\n  Plotly.newPlot(\n    \"cmp-hist\",\n    [\n      {\n        x: D_BASELINE.events.map((e) => e.latencyMs),\n        type: \"histogram\",\n        name: \"baseline\",\n        opacity: 0.5,\n        marker: { color: \"#238636\" },\n        nbinsx: 50,\n      },\n      {\n        x: D_CURRENT.events.map((e) => e.latencyMs),\n        type: \"histogram\",\n        name: \"current\",\n        opacity: 0.5,\n        marker: { color: \"#58a6ff\" },\n        nbinsx: 50,\n      },\n    ],\n    Object.assign({}, theme, {\n      title: { text: \"Latency distribution\" },\n      xaxis: Object.assign({}, theme.xaxis, {\n        title: { text: \"Latency (ms)\" },\n      }),\n      yaxis: Object.assign({}, theme.yaxis, { title: { text: \"Count\" } }),\n      barmode: \"overlay\",\n      showlegend: false,\n    }),\n    plotlyCfg,\n  );\n\n  // ─── Side-by-side box plots ───\n  Plotly.newPlot(\n    \"cmp-box\",\n    [\n      {\n        y: D_BASELINE.events.map((e) => e.latencyMs),\n        type: \"box\",\n        name: \"baseline\",\n        marker: { color: \"#238636\" },\n        boxpoints: false,\n      },\n      {\n        y: D_CURRENT.events.map((e) => e.latencyMs),\n        type: \"box\",\n        name: \"current\",\n        marker: { color: \"#58a6ff\" },\n        boxpoints: false,\n      },\n    ],\n    Object.assign({}, theme, {\n      title: { text: \"Latency comparison\" },\n      yaxis: Object.assign({}, theme.yaxis, {\n        title: { text: \"Latency (ms)\" },\n      }),\n      showlegend: false,\n    }),\n    plotlyCfg,\n  );\n  // ─── Save summary card ───\n  const copyBtn = document.getElementById(\"copy-summary\");\n  copyBtn.style.display = \"\";\n  copyBtn.textContent = \"Save summary card\";\n  copyBtn.addEventListener(\"click\", function () {\n    copyBtn.disabled = true;\n    copyBtn.textContent = \"Saving...\";\n\n    const bg = getComputedStyle(document.documentElement).getPropertyValue(\"--bg\").trim();\n\n    // Hide everything except summary table + throughput chart\n    const chartsEl = section.querySelector(\".charts\");\n    const chartDivs = chartsEl ? Array.from(chartsEl.children) : [];\n    for (let i = 1; i < chartDivs.length; i++) chartDivs[i].style.display = \"none\";\n\n    const header = document.querySelector(\".header\");\n    const stats = document.getElementById(\"stats\");\n    const runParams = document.getElementById(\"run-params\");\n    header.style.display = \"none\";\n    stats.style.display = \"none\";\n    runParams.style.display = \"none\";\n\n    htmlToImage.toPng(section, { backgroundColor: bg, pixelRatio: 2 })\n      .then(function (dataUrl) {\n        const a = document.createElement(\"a\");\n        a.download = \"mcp-stress-compare-\" + new Date().toISOString().replace(/[:.]/g, \"-\").slice(0, 19) + \".png\";\n        a.href = dataUrl;\n        a.click();\n      })\n      .catch(function (err) {\n        console.error(\"Save summary card failed:\", err);\n      })\n      .finally(function () {\n        for (let i = 1; i < chartDivs.length; i++) chartDivs[i].style.display = \"\";\n        header.style.display = \"\";\n        stats.style.display = \"\";\n        runParams.style.display = \"\";\n        copyBtn.disabled = false;\n        copyBtn.textContent = \"Save summary card\";\n      });\n  });\n})();\n";
